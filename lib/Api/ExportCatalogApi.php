<?php
/**
 * ExportCatalogApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * opendatasoft
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.12
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ExportCatalogApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ExportCatalogApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation exportDatasetsCSV
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     * @param  string $delimiter Provide a different delimiter (default &#39;,&#39;). (optional, default to ;)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function exportDatasetsCSV($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false', $delimiter = ';')
    {
        list($response) = $this->exportDatasetsCSVWithHttpInfo($source, $where, $search, $rows, $start, $timezone, $include_app_metas, $delimiter);
        return $response;
    }

    /**
     * Operation exportDatasetsCSVWithHttpInfo
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     * @param  string $delimiter Provide a different delimiter (default &#39;,&#39;). (optional, default to ;)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function exportDatasetsCSVWithHttpInfo($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false', $delimiter = ';')
    {
        $returnType = '\SplFileObject';
        $request = $this->exportDatasetsCSVRequest($source, $where, $search, $rows, $start, $timezone, $include_app_metas, $delimiter);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation exportDatasetsCSVAsync
     *
     * 
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     * @param  string $delimiter Provide a different delimiter (default &#39;,&#39;). (optional, default to ;)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportDatasetsCSVAsync($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false', $delimiter = ';')
    {
        return $this->exportDatasetsCSVAsyncWithHttpInfo($source, $where, $search, $rows, $start, $timezone, $include_app_metas, $delimiter)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation exportDatasetsCSVAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     * @param  string $delimiter Provide a different delimiter (default &#39;,&#39;). (optional, default to ;)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportDatasetsCSVAsyncWithHttpInfo($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false', $delimiter = ';')
    {
        $returnType = '\SplFileObject';
        $request = $this->exportDatasetsCSVRequest($source, $where, $search, $rows, $start, $timezone, $include_app_metas, $delimiter);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'exportDatasetsCSV'
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     * @param  string $delimiter Provide a different delimiter (default &#39;,&#39;). (optional, default to ;)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function exportDatasetsCSVRequest($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false', $delimiter = ';')
    {
        // verify the required parameter 'source' is set
        if ($source === null || (is_array($source) && count($source) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source when calling exportDatasetsCSV'
            );
        }
        if ($rows !== null && $rows > 100) {
            throw new \InvalidArgumentException('invalid value for "$rows" when calling ExportCatalogApi.exportDatasetsCSV, must be smaller than or equal to 100.');
        }
        if ($rows !== null && $rows < -1) {
            throw new \InvalidArgumentException('invalid value for "$rows" when calling ExportCatalogApi.exportDatasetsCSV, must be bigger than or equal to -1.');
        }

        if ($start !== null && $start < 0) {
            throw new \InvalidArgumentException('invalid value for "$start" when calling ExportCatalogApi.exportDatasetsCSV, must be bigger than or equal to 0.');
        }


        $resourcePath = '/{source}/exports/csv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($where)) {
            $queryParams['where'] = $where;
        } else
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if (is_array($search)) {
            $queryParams['search'] = $search;
        } else
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search);
        }
        // query params
        if ($rows !== null) {
            $queryParams['rows'] = ObjectSerializer::toQueryValue($rows);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start);
        }
        // query params
        if ($timezone !== null) {
            $queryParams['timezone'] = ObjectSerializer::toQueryValue($timezone);
        }
        // query params
        if ($include_app_metas !== null) {
            $queryParams['include_app_metas'] = ObjectSerializer::toQueryValue($include_app_metas);
        }
        // query params
        if ($delimiter !== null) {
            $queryParams['delimiter'] = ObjectSerializer::toQueryValue($delimiter);
        }

        // path params
        if ($source !== null) {
            $resourcePath = str_replace(
                '{' . 'source' . '}',
                ObjectSerializer::toPathValue($source),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/csv']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/csv'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apikey');
        if ($apiKey !== null) {
            $queryParams['apikey'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation exportDatasetsJson
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  bool $pretty Activate pretty print (optional, default to false)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function exportDatasetsJson($source, $where = null, $search = null, $rows = '10', $start = '0', $pretty = 'false', $timezone = 'UTC', $include_app_metas = 'false')
    {
        list($response) = $this->exportDatasetsJsonWithHttpInfo($source, $where, $search, $rows, $start, $pretty, $timezone, $include_app_metas);
        return $response;
    }

    /**
     * Operation exportDatasetsJsonWithHttpInfo
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  bool $pretty Activate pretty print (optional, default to false)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function exportDatasetsJsonWithHttpInfo($source, $where = null, $search = null, $rows = '10', $start = '0', $pretty = 'false', $timezone = 'UTC', $include_app_metas = 'false')
    {
        $returnType = '\SplFileObject';
        $request = $this->exportDatasetsJsonRequest($source, $where, $search, $rows, $start, $pretty, $timezone, $include_app_metas);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation exportDatasetsJsonAsync
     *
     * 
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  bool $pretty Activate pretty print (optional, default to false)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportDatasetsJsonAsync($source, $where = null, $search = null, $rows = '10', $start = '0', $pretty = 'false', $timezone = 'UTC', $include_app_metas = 'false')
    {
        return $this->exportDatasetsJsonAsyncWithHttpInfo($source, $where, $search, $rows, $start, $pretty, $timezone, $include_app_metas)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation exportDatasetsJsonAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  bool $pretty Activate pretty print (optional, default to false)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportDatasetsJsonAsyncWithHttpInfo($source, $where = null, $search = null, $rows = '10', $start = '0', $pretty = 'false', $timezone = 'UTC', $include_app_metas = 'false')
    {
        $returnType = '\SplFileObject';
        $request = $this->exportDatasetsJsonRequest($source, $where, $search, $rows, $start, $pretty, $timezone, $include_app_metas);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'exportDatasetsJson'
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  bool $pretty Activate pretty print (optional, default to false)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function exportDatasetsJsonRequest($source, $where = null, $search = null, $rows = '10', $start = '0', $pretty = 'false', $timezone = 'UTC', $include_app_metas = 'false')
    {
        // verify the required parameter 'source' is set
        if ($source === null || (is_array($source) && count($source) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source when calling exportDatasetsJson'
            );
        }
        if ($rows !== null && $rows > 100) {
            throw new \InvalidArgumentException('invalid value for "$rows" when calling ExportCatalogApi.exportDatasetsJson, must be smaller than or equal to 100.');
        }
        if ($rows !== null && $rows < -1) {
            throw new \InvalidArgumentException('invalid value for "$rows" when calling ExportCatalogApi.exportDatasetsJson, must be bigger than or equal to -1.');
        }

        if ($start !== null && $start < 0) {
            throw new \InvalidArgumentException('invalid value for "$start" when calling ExportCatalogApi.exportDatasetsJson, must be bigger than or equal to 0.');
        }


        $resourcePath = '/{source}/exports/json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($where)) {
            $queryParams['where'] = $where;
        } else
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if (is_array($search)) {
            $queryParams['search'] = $search;
        } else
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search);
        }
        // query params
        if ($rows !== null) {
            $queryParams['rows'] = ObjectSerializer::toQueryValue($rows);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start);
        }
        // query params
        if ($pretty !== null) {
            $queryParams['pretty'] = ObjectSerializer::toQueryValue($pretty);
        }
        // query params
        if ($timezone !== null) {
            $queryParams['timezone'] = ObjectSerializer::toQueryValue($timezone);
        }
        // query params
        if ($include_app_metas !== null) {
            $queryParams['include_app_metas'] = ObjectSerializer::toQueryValue($include_app_metas);
        }

        // path params
        if ($source !== null) {
            $resourcePath = str_replace(
                '{' . 'source' . '}',
                ObjectSerializer::toPathValue($source),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apikey');
        if ($apiKey !== null) {
            $queryParams['apikey'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation exportDatasetsRDF
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function exportDatasetsRDF($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        list($response) = $this->exportDatasetsRDFWithHttpInfo($source, $where, $search, $rows, $start, $timezone, $include_app_metas);
        return $response;
    }

    /**
     * Operation exportDatasetsRDFWithHttpInfo
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function exportDatasetsRDFWithHttpInfo($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        $returnType = '\SplFileObject';
        $request = $this->exportDatasetsRDFRequest($source, $where, $search, $rows, $start, $timezone, $include_app_metas);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation exportDatasetsRDFAsync
     *
     * 
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportDatasetsRDFAsync($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        return $this->exportDatasetsRDFAsyncWithHttpInfo($source, $where, $search, $rows, $start, $timezone, $include_app_metas)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation exportDatasetsRDFAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportDatasetsRDFAsyncWithHttpInfo($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        $returnType = '\SplFileObject';
        $request = $this->exportDatasetsRDFRequest($source, $where, $search, $rows, $start, $timezone, $include_app_metas);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'exportDatasetsRDF'
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function exportDatasetsRDFRequest($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        // verify the required parameter 'source' is set
        if ($source === null || (is_array($source) && count($source) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source when calling exportDatasetsRDF'
            );
        }
        if ($rows !== null && $rows > 100) {
            throw new \InvalidArgumentException('invalid value for "$rows" when calling ExportCatalogApi.exportDatasetsRDF, must be smaller than or equal to 100.');
        }
        if ($rows !== null && $rows < -1) {
            throw new \InvalidArgumentException('invalid value for "$rows" when calling ExportCatalogApi.exportDatasetsRDF, must be bigger than or equal to -1.');
        }

        if ($start !== null && $start < 0) {
            throw new \InvalidArgumentException('invalid value for "$start" when calling ExportCatalogApi.exportDatasetsRDF, must be bigger than or equal to 0.');
        }


        $resourcePath = '/{source}/exports/rdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($where)) {
            $queryParams['where'] = $where;
        } else
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if (is_array($search)) {
            $queryParams['search'] = $search;
        } else
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search);
        }
        // query params
        if ($rows !== null) {
            $queryParams['rows'] = ObjectSerializer::toQueryValue($rows);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start);
        }
        // query params
        if ($timezone !== null) {
            $queryParams['timezone'] = ObjectSerializer::toQueryValue($timezone);
        }
        // query params
        if ($include_app_metas !== null) {
            $queryParams['include_app_metas'] = ObjectSerializer::toQueryValue($include_app_metas);
        }

        // path params
        if ($source !== null) {
            $resourcePath = str_replace(
                '{' . 'source' . '}',
                ObjectSerializer::toPathValue($source),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/rdf+xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/rdf+xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apikey');
        if ($apiKey !== null) {
            $queryParams['apikey'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation exportDatasetsRSS
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function exportDatasetsRSS($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        list($response) = $this->exportDatasetsRSSWithHttpInfo($source, $where, $search, $rows, $start, $timezone, $include_app_metas);
        return $response;
    }

    /**
     * Operation exportDatasetsRSSWithHttpInfo
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function exportDatasetsRSSWithHttpInfo($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        $returnType = '\SplFileObject';
        $request = $this->exportDatasetsRSSRequest($source, $where, $search, $rows, $start, $timezone, $include_app_metas);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation exportDatasetsRSSAsync
     *
     * 
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportDatasetsRSSAsync($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        return $this->exportDatasetsRSSAsyncWithHttpInfo($source, $where, $search, $rows, $start, $timezone, $include_app_metas)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation exportDatasetsRSSAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportDatasetsRSSAsyncWithHttpInfo($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        $returnType = '\SplFileObject';
        $request = $this->exportDatasetsRSSRequest($source, $where, $search, $rows, $start, $timezone, $include_app_metas);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'exportDatasetsRSS'
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function exportDatasetsRSSRequest($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        // verify the required parameter 'source' is set
        if ($source === null || (is_array($source) && count($source) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source when calling exportDatasetsRSS'
            );
        }
        if ($rows !== null && $rows > 100) {
            throw new \InvalidArgumentException('invalid value for "$rows" when calling ExportCatalogApi.exportDatasetsRSS, must be smaller than or equal to 100.');
        }
        if ($rows !== null && $rows < -1) {
            throw new \InvalidArgumentException('invalid value for "$rows" when calling ExportCatalogApi.exportDatasetsRSS, must be bigger than or equal to -1.');
        }

        if ($start !== null && $start < 0) {
            throw new \InvalidArgumentException('invalid value for "$start" when calling ExportCatalogApi.exportDatasetsRSS, must be bigger than or equal to 0.');
        }


        $resourcePath = '/{source}/exports/rss';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($where)) {
            $queryParams['where'] = $where;
        } else
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if (is_array($search)) {
            $queryParams['search'] = $search;
        } else
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search);
        }
        // query params
        if ($rows !== null) {
            $queryParams['rows'] = ObjectSerializer::toQueryValue($rows);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start);
        }
        // query params
        if ($timezone !== null) {
            $queryParams['timezone'] = ObjectSerializer::toQueryValue($timezone);
        }
        // query params
        if ($include_app_metas !== null) {
            $queryParams['include_app_metas'] = ObjectSerializer::toQueryValue($include_app_metas);
        }

        // path params
        if ($source !== null) {
            $resourcePath = str_replace(
                '{' . 'source' . '}',
                ObjectSerializer::toPathValue($source),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apikey');
        if ($apiKey !== null) {
            $queryParams['apikey'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation exportDatasetsTTL
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function exportDatasetsTTL($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        list($response) = $this->exportDatasetsTTLWithHttpInfo($source, $where, $search, $rows, $start, $timezone, $include_app_metas);
        return $response;
    }

    /**
     * Operation exportDatasetsTTLWithHttpInfo
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function exportDatasetsTTLWithHttpInfo($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        $returnType = '\SplFileObject';
        $request = $this->exportDatasetsTTLRequest($source, $where, $search, $rows, $start, $timezone, $include_app_metas);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation exportDatasetsTTLAsync
     *
     * 
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportDatasetsTTLAsync($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        return $this->exportDatasetsTTLAsyncWithHttpInfo($source, $where, $search, $rows, $start, $timezone, $include_app_metas)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation exportDatasetsTTLAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportDatasetsTTLAsyncWithHttpInfo($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        $returnType = '\SplFileObject';
        $request = $this->exportDatasetsTTLRequest($source, $where, $search, $rows, $start, $timezone, $include_app_metas);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'exportDatasetsTTL'
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function exportDatasetsTTLRequest($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        // verify the required parameter 'source' is set
        if ($source === null || (is_array($source) && count($source) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source when calling exportDatasetsTTL'
            );
        }
        if ($rows !== null && $rows > 100) {
            throw new \InvalidArgumentException('invalid value for "$rows" when calling ExportCatalogApi.exportDatasetsTTL, must be smaller than or equal to 100.');
        }
        if ($rows !== null && $rows < -1) {
            throw new \InvalidArgumentException('invalid value for "$rows" when calling ExportCatalogApi.exportDatasetsTTL, must be bigger than or equal to -1.');
        }

        if ($start !== null && $start < 0) {
            throw new \InvalidArgumentException('invalid value for "$start" when calling ExportCatalogApi.exportDatasetsTTL, must be bigger than or equal to 0.');
        }


        $resourcePath = '/{source}/exports/ttl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($where)) {
            $queryParams['where'] = $where;
        } else
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if (is_array($search)) {
            $queryParams['search'] = $search;
        } else
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search);
        }
        // query params
        if ($rows !== null) {
            $queryParams['rows'] = ObjectSerializer::toQueryValue($rows);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start);
        }
        // query params
        if ($timezone !== null) {
            $queryParams['timezone'] = ObjectSerializer::toQueryValue($timezone);
        }
        // query params
        if ($include_app_metas !== null) {
            $queryParams['include_app_metas'] = ObjectSerializer::toQueryValue($include_app_metas);
        }

        // path params
        if ($source !== null) {
            $resourcePath = str_replace(
                '{' . 'source' . '}',
                ObjectSerializer::toPathValue($source),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/turtle']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/turtle'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apikey');
        if ($apiKey !== null) {
            $queryParams['apikey'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation exportDatasetsXLS
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function exportDatasetsXLS($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        list($response) = $this->exportDatasetsXLSWithHttpInfo($source, $where, $search, $rows, $start, $timezone, $include_app_metas);
        return $response;
    }

    /**
     * Operation exportDatasetsXLSWithHttpInfo
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function exportDatasetsXLSWithHttpInfo($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        $returnType = '\SplFileObject';
        $request = $this->exportDatasetsXLSRequest($source, $where, $search, $rows, $start, $timezone, $include_app_metas);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation exportDatasetsXLSAsync
     *
     * 
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportDatasetsXLSAsync($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        return $this->exportDatasetsXLSAsyncWithHttpInfo($source, $where, $search, $rows, $start, $timezone, $include_app_metas)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation exportDatasetsXLSAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportDatasetsXLSAsyncWithHttpInfo($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        $returnType = '\SplFileObject';
        $request = $this->exportDatasetsXLSRequest($source, $where, $search, $rows, $start, $timezone, $include_app_metas);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'exportDatasetsXLS'
     *
     * @param  string $source Each source represents a different catalog of datasets you&#39;ll be able to query.  There are 2 sources available:  * catalog: the catalog of datasets on your portal * opendatasoft: Opendatasoft&#39;s repository of public datasets, also available at   [data.opendatasoft.com](https://data.opendatasoft.com/page/home/) (required)
     * @param  string[] $where An array of filters.  A filter is a text expression performing a simple full-text search that can also include logical operations (NOT, AND, OR...) as well as lots of other functions, thus performing more complex and more precise searches.  Read [the query language reference](https://docs.opendatasoft.com/api/explore/v2.html#where-clause) for more details. (optional)
     * @param  string[] $search An array of full text search.  A full text search performs a prefixed text search for each provided terms in all visible fields of a catalog/dataset. (optional)
     * @param  int $rows Number of items to return.  To use in conjonction with start to implement pagination.  Rows maximum value is 100. To retrive more data use export entry points. (optional, default to 10)
     * @param  int $start Index of the first item to return (starting at 0).  To use in conjonction with rows to implement pagination. (optional, default to 0)
     * @param  string $timezone Set timezone for datetime fields (optional, default to UTC)
     * @param  bool $include_app_metas Explicitely request application metas for each datasets. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function exportDatasetsXLSRequest($source, $where = null, $search = null, $rows = '10', $start = '0', $timezone = 'UTC', $include_app_metas = 'false')
    {
        // verify the required parameter 'source' is set
        if ($source === null || (is_array($source) && count($source) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source when calling exportDatasetsXLS'
            );
        }
        if ($rows !== null && $rows > 100) {
            throw new \InvalidArgumentException('invalid value for "$rows" when calling ExportCatalogApi.exportDatasetsXLS, must be smaller than or equal to 100.');
        }
        if ($rows !== null && $rows < -1) {
            throw new \InvalidArgumentException('invalid value for "$rows" when calling ExportCatalogApi.exportDatasetsXLS, must be bigger than or equal to -1.');
        }

        if ($start !== null && $start < 0) {
            throw new \InvalidArgumentException('invalid value for "$start" when calling ExportCatalogApi.exportDatasetsXLS, must be bigger than or equal to 0.');
        }


        $resourcePath = '/{source}/exports/xls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($where)) {
            $queryParams['where'] = $where;
        } else
        if ($where !== null) {
            $queryParams['where'] = ObjectSerializer::toQueryValue($where);
        }
        // query params
        if (is_array($search)) {
            $queryParams['search'] = $search;
        } else
        if ($search !== null) {
            $queryParams['search'] = ObjectSerializer::toQueryValue($search);
        }
        // query params
        if ($rows !== null) {
            $queryParams['rows'] = ObjectSerializer::toQueryValue($rows);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start);
        }
        // query params
        if ($timezone !== null) {
            $queryParams['timezone'] = ObjectSerializer::toQueryValue($timezone);
        }
        // query params
        if ($include_app_metas !== null) {
            $queryParams['include_app_metas'] = ObjectSerializer::toQueryValue($include_app_metas);
        }

        // path params
        if ($source !== null) {
            $resourcePath = str_replace(
                '{' . 'source' . '}',
                ObjectSerializer::toPathValue($source),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['xls']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['xls'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apikey');
        if ($apiKey !== null) {
            $queryParams['apikey'] = $apiKey;
        }
        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
